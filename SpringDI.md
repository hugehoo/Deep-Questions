### DI란?

- 의존성 주입, 스프링 프레임워크에서 지원하는 IoC(제어의 역전)의 형태
    - 의존성이란?
        - A 객체가 B 객체에 영향을 준다면, B 객체는 A 객체를 의존한다고 말한다.
        - DI 는 클래스 사이의 의존관계를 빈 설정 정보 파일(ex XML, AppConfig etc)을 바탕으로 컨테이너가 자동적으로 연결해주는 것을 의미
        - 개발자는 빈 설정 파일에 의존관계가 필요하다는 정보만 추가하면 된다.
        - 컨테이너가 실행 흐름의 주체가 되어(제어가 역전됨) Application 코드에 의존관계를 주입하는 것

    - `의존성 주입이 필요한 이유`
        - 클래스를 재사용할 가능성이 높아진다. (예시없을까)
        - 다른 클래스와 독립적으로 클래스를 테스트 할 수 있다.

    - 의존성 주입 3가지 방법
        - 생성자 주입 : 가장 권장되는 방법
            - `객체가 생성될 때 참조`하므로 NPE 방지 (null 값을 참조하면서 객체가 생성될 순 없으니)
            - 주입할 객체를 `final` 로 지정하여 immutable 하게 설정
              - 이로 인해 주입되는 빈은 null 일 수 없게 된다.(null 을 직접 할당하는 경우가 아니라면)
            - 순환참조 방지 및 감지 가능
            - 테스트 코드 개발 용이 (필드 주입에선 힘들다)
            - 생성자 주입을 하면 전략 패턴을 사용하게 된다. (Open Closed Principle)
        - 필드 주입
        - 수정자 주입
            - 수정자 주입방식은 런타임시 의존 관계가 주입된다. (낮은 결합도를 가지게 됨)
            - `문제는` 수정자를 통해 Service 의 구현체를 주입하지 않아도 Controller 객체는 생성 가능하다.
                - 이는 NPE 가 발생할 여지를 남긴다. 왜냐하면 주입이 필요한 객체가 주입되지 않아도 얼마든지 객체를 생성할 수 있기 때문이다. 이런 경우엔 객체가 생성되지 못하도록 막아야한다.

    - 빈을 주입하는 순서
        - 수정자 주입 : 주입 받는 빈의 생성자를 호출하여 빈을 찾는다. 그 후에 생성자 인자에 사용되는 빈을 찾는다. 그 이후 주입하려는 빈 객체의 수정자를 호출하여 주입
        - 필드 주입 : 수정자 주입 방법과 동일하게 먼저 빈을 생성. 필요한 빈을 찾아 주입한다. 먼저 빈을 생성한 후, 필드에 대해 주입한다.
        - 생성자 주입 : 객체를 생성하는 시점에 필요한 빈을 주입. 그러기 위해 생성자 인자에 사용되는 빈을 먼저 찾는다. 그 후 생성자를 호출한다.
            - `즉 먼저 (주입받는) 빈을 생성하지 않는다는 점`이 핵심이다.
            - 이게 왜 핵심이냐면, (주입받는) 빈을 먼저 생성하면, 의존 주입이 이뤄지지 않아도 (주입받는) 빈이 먼저 생성될 수 있기 때문에 런타임시 NPE가 발생할 가능성이 다분하다.


> ref
- https://yaboong.github.io/spring/2019/08/29/why-field-injection-is-bad/
- https://madplay.github.io/post/why-constructor-injection-is-better-than-field-injection